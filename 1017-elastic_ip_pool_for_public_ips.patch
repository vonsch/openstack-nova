diff --git a/nova/network/l3.py b/nova/network/l3.py
index e41e631..361148a 100644
--- a/nova/network/l3.py
+++ b/nova/network/l3.py
@@ -51,7 +51,7 @@ class L3Driver(object):
         """:returns: True/False (whether the driver is initialized)"""
         raise NotImplementedError()
 
-    def add_floating_ip(self, floating_ip, fixed_ip, l3_interface_id):
+    def add_floating_ip(self, floating_ip, fixed_ip, l3_interface_id, insert):
         """Add a floating IP bound to the fixed IP with an optional
            l3_interface_id.  Some drivers won't care about the
            l3_interface_id so just pass None in that case"""
@@ -99,10 +99,10 @@ class LinuxNetL3(L3Driver):
     def remove_gateway(self, network_ref):
         linux_net.unplug(network_ref)
 
-    def add_floating_ip(self, floating_ip, fixed_ip, l3_interface_id):
+    def add_floating_ip(self, floating_ip, fixed_ip, l3_interface_id, insert=False):
         linux_net.bind_floating_ip(floating_ip, l3_interface_id)
         linux_net.ensure_floating_forward(floating_ip, fixed_ip,
-                                          l3_interface_id)
+                                          l3_interface_id, insert=insert)
 
     def remove_floating_ip(self, floating_ip, fixed_ip, l3_interface_id):
         linux_net.unbind_floating_ip(floating_ip, l3_interface_id)
@@ -143,7 +143,7 @@ class NullL3(L3Driver):
     def remove_gateway(self, network_ref):
         pass
 
-    def add_floating_ip(self, floating_ip, fixed_ip, l3_interface_id):
+    def add_floating_ip(self, floating_ip, fixed_ip, l3_interface_id, insert):
         pass
 
     def remove_floating_ip(self, floating_ip, fixed_ip, l3_interface_id):
diff --git a/nova/network/linux_net.py b/nova/network/linux_net.py
index 600d5e5..9005c13 100644
--- a/nova/network/linux_net.py
+++ b/nova/network/linux_net.py
@@ -198,7 +198,7 @@ class IptablesTable(object):
                                         self.rules)
         self.rules = filter(lambda r: jump_snippet not in r.rule, self.rules)
 
-    def add_rule(self, chain, rule, wrap=True, top=False):
+    def add_rule(self, chain, rule, wrap=True, top=False, insert=False):
         """Add a rule to the table.
 
         This is just like what you'd feed to iptables, just without
@@ -215,7 +215,10 @@ class IptablesTable(object):
         if '$' in rule:
             rule = ' '.join(map(self._wrap_target_chain, rule.split(' ')))
 
-        self.rules.append(IptablesRule(chain, rule, wrap, top))
+        if insert == True:
+            self.rules.insert(0,IptablesRule(chain, rule, wrap, top))
+        else:
+            self.rules.append(IptablesRule(chain, rule, wrap, top))
 
     def _wrap_target_chain(self, s):
         if s.startswith('$'):
@@ -622,10 +625,10 @@ def ensure_vpn_forward(public_ip, port, private_ip):
     iptables_manager.apply()
 
 
-def ensure_floating_forward(floating_ip, fixed_ip, device):
+def ensure_floating_forward(floating_ip, fixed_ip, device, insert=False):
     """Ensure floating ip forwarding rule."""
     for chain, rule in floating_forward_rules(floating_ip, fixed_ip, device):
-        iptables_manager.ipv4['nat'].add_rule(chain, rule)
+        iptables_manager.ipv4['nat'].add_rule(chain, rule, insert=insert)
     iptables_manager.apply()
 
 
diff --git a/nova/network/manager.py b/nova/network/manager.py
index 6a51f05..0e9dd5b 100644
--- a/nova/network/manager.py
+++ b/nova/network/manager.py
@@ -284,11 +284,25 @@ class FloatingIP(object):
 
         admin_context = context.get_admin_context()
         try:
-            floating_ips = self.db.floating_ip_get_all_by_host(admin_context,
-                                                               self.host)
+            unsorted_floating_ips = self.db.floating_ip_get_all_by_host(admin_context,
+                                                                        self.host)
         except exception.NotFound:
             return
 
+        # Elastic pool at the top of list, Public pool at the end of list
+        floating_ips = []
+        public_ips   = []
+        elastic_ips  = []
+        for floating_ip in unsorted_floating_ips:
+            if floating_ip.get('pool') == "public":
+                 public_ips.append(floating_ip)
+            elif floating_ip.get('pool') == "elastic":
+                 elastic_ips.append(floating_ip)
+            else:
+                 floating_ips.append(floating_ip)
+
+        floating_ips = elastic_ips + floating_ips + public_ips
+
         for floating_ip in floating_ips:
             fixed_ip_id = floating_ip.get('fixed_ip_id')
             if fixed_ip_id:
@@ -559,6 +573,12 @@ class FloatingIP(object):
         @utils.synchronized(unicode(floating_address))
         def do_associate():
             # associate floating ip
+            floating_ip = self.db.floating_ip_get_by_address(context,
+                                                         floating_address)
+            insert = False
+            if floating_ip.get('pool') == "elastic":
+               insert = True
+
             res = self.db.floating_ip_fixed_ip_associate(context,
                                                          floating_address,
                                                          fixed_address,
@@ -569,7 +589,7 @@ class FloatingIP(object):
             try:
                 # gogo driver time
                 self.l3driver.add_floating_ip(floating_address, fixed_address,
-                        interface)
+                        interface, insert=insert)
             except exception.ProcessExecutionError as e:
                 self.db.floating_ip_disassociate(context, floating_address)
                 if "Cannot find device" in str(e):
