From 8da2e118d9fe0de38c590fb05314c1bdd9de5180 Mon Sep 17 00:00:00 2001
From: Radek Smidl <radek.smidl@marin.gooddata.com>
Date: Thu, 1 Aug 2013 14:51:09 +0200
Subject: [PATCH 2/2] FEATURE: PCI-1718 - LVM Thin volumes support added

---
 nova/utils.py              | 44 ++++++++++++++++++++++++++++++++++++++++++++
 nova/virt/libvirt/utils.py | 21 ++-------------------
 nova/volume/driver.py      | 33 +++++++++++++++++++++++++++++++--
 3 files changed, 77 insertions(+), 21 deletions(-)

diff --git a/nova/utils.py b/nova/utils.py
index 48db295..c66e305 100644
--- a/nova/utils.py
+++ b/nova/utils.py
@@ -1411,3 +1411,47 @@ def last_bytes(file_like_object, num):
 
     remaining = file_like_object.tell()
     return (file_like_object.read(), remaining)
+
+
+def human2bytes(s):
+    """ Attempts to guess the string format based on default symbols
+    set and return the corresponding bytes as an integer.
+
+    :param s: size in human readable format ('1M', '1G', ...)
+
+    :returns: bytes
+    """
+    symbols = ('B', 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
+    letter = s[-1:].strip().upper()
+    num = s[:-1]
+    assert num.isdigit() and letter in symbols
+    num = float(num)
+    prefix = {symbols[0]:1}
+    for i, s in enumerate(symbols[1:]):
+        prefix[s] = 1 << (i + 1) * 10
+    return int(num * prefix[letter])
+
+
+def create_thin_pool(pool_path):
+    """Create the LVM thin pool.
+
+    :param pool_path: thin pool path, for example "nova-volumes/nova-volumes-pool"
+    """
+    # leave some spare space for troubleshooting
+    execute('lvcreate', '-T', '-l', '99%FREE', pool_path, run_as_root=True)
+
+
+def thin_pool_allocated_size(pool_name):
+    """Return allocated space in thin pool in bytes.
+
+    :param pool_name: thin pool name
+    """
+    allocated_size = 0
+    out, err = execute('lvs', '--units', 'b', '--option', 'pool_lv,lv_size',
+                       '--noheadings', '--nosuffix', '--separator', ',',
+                       run_as_root=True)
+    lv_list = [[ y[0].strip(), y[1]] for y in [ x.split(',') for x in out.splitlines() ]]
+    for lv in lv_list:
+        if lv[0] == pool_name:
+            allocated_size += int(lv[1])
+    return allocated_size
diff --git a/nova/virt/libvirt/utils.py b/nova/virt/libvirt/utils.py
index b73ddca..cad2a75 100644
--- a/nova/virt/libvirt/utils.py
+++ b/nova/virt/libvirt/utils.py
@@ -130,13 +130,12 @@ def create_lvm_image(vg, lv, size, sparse=False, thin=False):
         pool_name = "%s-pool" % vg
         pool_path = '%s/%s' % (vg, pool_name)
         if pool_name not in list_logical_volumes(vg):
-            # leave some spare space for troubleshooting
-            execute('lvcreate', '-T', '-l', '99%FREE', pool_path, run_as_root=True)
+            utils.create_thin_pool(pool_path)
 
         # check overcommit limit
         allowed_overcommit = float(FLAGS.libvirt_thin_logical_volumes_overcommit)
         pool_size = logical_volume_size(pool_path)
-        pool_allocated_size = thin_pool_allocated_size(pool_name)
+        pool_allocated_size = utils.thin_pool_allocated_size(pool_name)
         overcommit = (float(size) + float(pool_allocated_size)) / float(pool_size)
         if overcommit > allowed_overcommit:
             LOG.error(_('The thin pool overcommit limit exceeded (%f > %f).') % (overcommit, allowed_overcommit))
@@ -150,22 +149,6 @@ def create_lvm_image(vg, lv, size, sparse=False, thin=False):
     execute(*cmd, run_as_root=True, attempts=3)
 
 
-def thin_pool_allocated_size(pool_name):
-    """Return allocated space in thin pool in bytes.
-
-    :param pool_name: thin pool name
-    """
-    allocated_size = 0
-    out, err = execute('lvs', '--units', 'b', '--option', 'pool_lv,lv_size',
-                       '--noheadings', '--nosuffix', '--separator', ',',
-                       run_as_root=True)
-    lv_list = [[ y[0].strip(), y[1]] for y in [ x.split(',') for x in out.splitlines() ]]
-    for lv in lv_list:
-        if lv[0] == pool_name:
-            allocated_size += int(lv[1])
-    return allocated_size
-
-
 def volume_group_free_space(vg):
     """Return available space on volume group in bytes.
 
diff --git a/nova/volume/driver.py b/nova/volume/driver.py
index 638b710..6b74466 100644
--- a/nova/volume/driver.py
+++ b/nova/volume/driver.py
@@ -38,6 +38,8 @@ from socket import gethostbyname
 
 from nova.api.ec2 import ec2utils
 
+from nova.virt.libvirt.utils import logical_volume_size
+
 LOG = logging.getLogger(__name__)
 
 volume_opts = [
@@ -79,6 +81,13 @@ volume_opts = [
                default=None,
                help='where to store temporary image files if the volume '
                     'driver does not write them directly to the volume'),
+    cfg.BoolOpt('libvirt_thin_logical_volumes',
+                default=False,
+                help='Create thin provisioned logical volumes (with virtualsize)'
+                     ' if this flag is set to True.'),
+    cfg.FloatOpt('libvirt_thin_logical_volumes_overcommit',
+                 default=1.5,
+                 help='Maximum thin pool overcommit ratio.'),
     ]
 
 FLAGS = flags.FLAGS
@@ -123,8 +132,28 @@ class VolumeDriver(object):
             raise exception.VolumeBackendAPIException(data=exception_message)
 
     def _create_volume(self, volume_name, sizestr):
-        self._try_execute('lvcreate', '-L', sizestr, '-n',
-                          volume_name, FLAGS.volume_group, run_as_root=True)
+        if FLAGS.libvirt_thin_logical_volumes:
+            # check if the thin pool exists
+            pool_name = "%s-pool" % FLAGS.volume_group
+            pool_path = '%s/%s' % (FLAGS.volume_group, pool_name)
+            if self._volume_not_present(pool_name):
+                # create the thin pool
+                utils.create_thin_pool(pool_path)
+            # check overcommit limit
+            size = utils.human2bytes(sizestr)
+            allowed_overcommit = float(FLAGS.libvirt_thin_logical_volumes_overcommit)
+            pool_size = logical_volume_size(pool_path)
+            pool_allocated_size = utils.thin_pool_allocated_size(pool_name)
+            overcommit = (float(size) + float(pool_allocated_size)) / float(pool_size)
+            if overcommit > allowed_overcommit:
+                exception_message = (_('The thin pool overcommit limit exceeded (%f > %f).') % (overcommit, allowed_overcommit))
+                raise exception.VolumeBackendAPIException(data=exception_message)
+            # create volume within the thinpool
+            self._try_execute('lvcreate', '--virtualsize', sizestr, '-n',
+                              volume_name, '-T', pool_path, run_as_root=True)
+        else:
+            self._try_execute('lvcreate', '-L', sizestr, '-n',
+                              volume_name, FLAGS.volume_group, run_as_root=True)
 
     def _copy_volume(self, srcstr, deststr, size_in_g):
         # Use O_DIRECT to avoid thrashing the system buffer cache
-- 
1.8.1.4

