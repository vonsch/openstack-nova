From 4e57f9a6f552e3516917ecfcb48aab3d9a9b8482 Mon Sep 17 00:00:00 2001
From: Eoghan Glynn <eglynn@redhat.com>
Date: Mon, 9 Jul 2012 11:59:56 +0000
Subject: [PATCH] Support EC2 CreateImage API for boot-from-volume

Fixes bug lp 988335

For fidelity with AWS, where the EC2 CreateImage API is only
supported for EBS-backed instances, we now support this API
for booted-from-volume nova servers.

We create a "place-holder" image in glance with the image data
being effectively empty, and the following properties set:

  * the imaged instance's kernel and ramdisk IDs
  * block device mapping containing the appropriate snapshot ID(s)

so that we can boot from this image without providing additional
context (such as via the nova boot --block-device-mapping option)

Change-Id: I0b3d18d7922f2ad1bc687fa88e2f5d4cf5aa068b
---
 nova/api/ec2/cloud.py            |   44 ++++++++++++++++++++++------
 nova/tests/api/ec2/test_cloud.py |   59 +++++++++++++++++++++++++++++++++----
 2 files changed, 87 insertions(+), 16 deletions(-)

diff --git a/nova/api/ec2/cloud.py b/nova/api/ec2/cloud.py
index 91182e8..47325af 100644
--- a/nova/api/ec2/cloud.py
+++ b/nova/api/ec2/cloud.py
@@ -1591,6 +1591,7 @@ class CloudController(object):
         # NOTE(yamahata): name/description are ignored by register_image(),
         #                 do so here
         no_reboot = kwargs.get('no_reboot', False)
+        name = kwargs.get('name')
         validate_ec2_id(instance_id)
         ec2_instance_id = instance_id
         instance_id = ec2utils.ec2_id_to_id(ec2_instance_id)
@@ -1624,14 +1625,22 @@ class CloudController(object):
                     raise exception.EC2APIError(
                         _('Couldn\'t stop instance with in %d sec') % timeout)
 
-        src_image = self._get_image(context, instance['image_ref'])
-        properties = src_image['properties']
+        glance_uuid = instance['image_ref']
+        ec2_image_id = ec2utils.glance_id_to_ec2_id(context, glance_uuid)
+        src_image = self._get_image(context, ec2_image_id)
+        new_image = dict(src_image)
+        properties = new_image['properties']
         if instance['root_device_name']:
             properties['root_device_name'] = instance['root_device_name']
 
+        # meaningful image name
+        name_map = dict(instance=instance['uuid'], now=utils.isotime())
+        new_image['name'] = (name or
+                             _('image of %(instance)s at %(now)s') % name_map)
+
         mapping = []
         bdms = db.block_device_mapping_get_all_by_instance(context,
-                                                           instance_id)
+                                                           instance['uuid'])
         for bdm in bdms:
             if bdm.no_device:
                 continue
@@ -1644,15 +1653,16 @@ class CloudController(object):
                     m[attr] = val
 
             volume_id = m.get('volume_id')
-            if m.get('snapshot_id') and volume_id:
+            snapshot_id = m.get('snapshot_id')
+            if snapshot_id and volume_id:
                 # create snapshot based on volume_id
                 volume = self.volume_api.get(context, volume_id)
                 # NOTE(yamahata): Should we wait for snapshot creation?
                 #                 Linux LVM snapshot creation completes in
                 #                 short time, it doesn't matter for now.
+                name = _('snapshot for %s') % new_image['name']
                 snapshot = self.volume_api.create_snapshot_force(
-                        context, volume, volume['display_name'],
-                        volume['display_description'])
+                        context, volume, name, volume['display_description'])
                 m['snapshot_id'] = snapshot['id']
                 del m['volume_id']
 
@@ -1679,11 +1689,27 @@ class CloudController(object):
             properties['block_device_mapping'] = mapping
 
         for attr in ('status', 'location', 'id'):
-            src_image.pop(attr, None)
+            new_image.pop(attr, None)
+
+        # the new image is simply a bucket of properties (particularly the
+        # block device mapping, kernel and ramdisk IDs) with no image data,
+        # hence the zero size
+        new_image['size'] = 0
+
+        def _unmap_id_property(properties, name):
+            if properties[name]:
+                properties[name] = ec2utils.id_to_glance_id(context,
+                                                            properties[name])
 
-        image_id = self._register_image(context, src_image)
+        # ensure the ID properties are unmapped back to the glance UUID
+        _unmap_id_property(properties, 'kernel_id')
+        _unmap_id_property(properties, 'ramdisk_id')
+
+        new_image = self.image_service.service.create(context, new_image,
+                                                      data='')
+        ec2_id = ec2utils.glance_id_to_ec2_id(context, new_image['id'])
 
         if restart_instance:
             self.compute_api.start(context, instance_id=instance_id)
 
-        return {'imageId': image_id}
+        return {'imageId': ec2_id}
diff --git a/nova/tests/api/ec2/test_cloud.py b/nova/tests/api/ec2/test_cloud.py
index 4ed3c04..01ac95a 100644
--- a/nova/tests/api/ec2/test_cloud.py
+++ b/nova/tests/api/ec2/test_cloud.py
@@ -2064,13 +2064,58 @@ class CloudTestCase(test.TestCase):
                   'max_count': 1}
         ec2_instance_id = self._run_instance(**kwargs)
 
-        # TODO(yamahata): s3._s3_create() can't be tested easily by unit test
-        #                 as there is no unit test for s3.create()
-        ## result = self.cloud.create_image(self.context, ec2_instance_id,
-        ##                                  no_reboot=True)
-        ## ec2_image_id = result['imageId']
-        ## created_image = self.cloud.describe_images(self.context,
-        ##                                            [ec2_image_id])
+        def fake_show(meh, context, id):
+            bdm = [dict(snapshot_id=snapshots[0],
+                        volume_size=1,
+                        device_name='vda',
+                        delete_on_termination=False)]
+            props = dict(kernel_id='cedef40a-ed67-4d10-800e-17455edce175',
+                         ramdisk_id='76fa36fc-c930-4bf3-8c8a-ea2a2420deb6',
+                         block_device_mapping=bdm)
+            return dict(id=id,
+                        properties=props,
+                        container_format='ami',
+                        status='active',
+                        is_public=True)
+
+        self.stubs.Set(fake._FakeImageService, 'show', fake_show)
+
+        def fake_block_device_mapping_get_all_by_instance(context, inst_id):
+            class BDM(object):
+                def __init__(self):
+                    self.no_device = None
+                    self.values = dict(snapshot_id=snapshots[0],
+                                       volume_id=volumes[0],
+                                       virtual_name=None,
+                                       volume_size=1,
+                                       device_name='vda',
+                                       delete_on_termination=False)
+
+                def __getattr__(self, name):
+                    return self.values.get(name)
+
+                def __getitem__(self, key):
+                    return self.values.get(key)
+
+            return [BDM()]
+
+        self.stubs.Set(db, 'block_device_mapping_get_all_by_instance',
+                       fake_block_device_mapping_get_all_by_instance)
+
+        result = self.cloud.create_image(self.context, ec2_instance_id,
+                                         no_reboot=True)
+        ec2_ids = [result['imageId']]
+        created_image = self.cloud.describe_images(self.context,
+                                                   ec2_ids)['imagesSet'][0]
+
+        self.assertTrue('blockDeviceMapping' in created_image)
+        bdm = created_image['blockDeviceMapping'][0]
+        self.assertEquals(bdm.get('deviceName'), 'vda')
+        self.assertTrue('ebs' in bdm)
+        self.assertEquals(bdm['ebs'].get('snapshotId'),
+                          'snap-%08x' % snapshots[0])
+        self.assertEquals(created_image.get('kernelId'), 'aki-00000001')
+        self.assertEquals(created_image.get('ramdiskId'), 'ari-00000002')
 
         self.cloud.terminate_instances(self.context, [ec2_instance_id])
         for vol in volumes:
