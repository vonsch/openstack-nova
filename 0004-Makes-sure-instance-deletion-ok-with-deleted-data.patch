From ae280ca43eafeee48b1466ccd45db979c86ae5ce Mon Sep 17 00:00:00 2001
From: Vishvananda Ishaya <vishvananda@gmail.com>
Date: Fri, 17 Aug 2012 15:03:46 -0700
Subject: [PATCH 04/10] Makes sure instance deletion ok with deleted data

Commit 5ad1dea4 added changed the network deallocation code to
work with deleted instances. This was done by setting the context
to read deleted records. Unfortunately this was done a little too
broadly, leading to a new bug where a deleted floating_ip will
cause an instance to not be able to be deleted.

This fixes the issue by limiting the use of read_deleted context
to only the places it is trying to access the instance record. It
adds a test  to verify that the code works with a duplicate
deleted floating_ip and updates the existing test for a deleted
instance to exercise the entire code path.

Fixes bug 1038266

Change-Id: I1aef94369e5bcf951e78e89b1eded5305cf36b53
(cherry-picked from commit 1f98e28a80077760394201f79de04a0924b9ad3f)
---
 nova/db/sqlalchemy/api.py          |  6 ++++--
 nova/network/manager.py            | 13 +++---------
 nova/tests/network/test_manager.py | 41 +++++++++++++++++++++++++++++++++++---
 3 files changed, 45 insertions(+), 15 deletions(-)

diff --git a/nova/db/sqlalchemy/api.py b/nova/db/sqlalchemy/api.py
index ca07565..affaa86 100644
--- a/nova/db/sqlalchemy/api.py
+++ b/nova/db/sqlalchemy/api.py
@@ -1026,7 +1026,8 @@ def fixed_ip_get(context, id, session=None):
     # FIXME(sirp): shouldn't we just use project_only here to restrict the
     # results?
     if is_user_context(context) and result['instance_id'] is not None:
-        instance = instance_get(context, result['instance_id'], session)
+        instance = instance_get(context.elevated(read_deleted='yes'),
+                                result['instance_id'], session)
         authorize_project_context(context, instance.project_id)
 
     return result
@@ -1055,7 +1056,8 @@ def fixed_ip_get_by_address(context, address, session=None):
     # NOTE(sirp): shouldn't we just use project_only here to restrict the
     # results?
     if is_user_context(context) and result['instance_id'] is not None:
-        instance = instance_get(context, result['instance_id'], session)
+        instance = instance_get(context.elevated(read_deleted='yes'),
+                                result['instance_id'], session)
         authorize_project_context(context, instance.project_id)
 
     return result
diff --git a/nova/network/manager.py b/nova/network/manager.py
index 1b9e98e..8b35404 100644
--- a/nova/network/manager.py
+++ b/nova/network/manager.py
@@ -345,15 +345,8 @@ class FloatingIP(object):
         """
         instance_id = kwargs.get('instance_id')
 
-        # NOTE(francois.charlier): in some cases the instance might be
-        # deleted before the IPs are released, so we need to get deleted
-        # instances too
-        read_deleted_context = context.elevated(read_deleted='yes')
-        LOG.debug(_("floating IP deallocation for instance |%s|"), instance_id,
-                                                  context=read_deleted_context)
-
         try:
-            fixed_ips = self.db.fixed_ip_get_by_instance(read_deleted_context,
+            fixed_ips = self.db.fixed_ip_get_by_instance(context,
                                                          instance_id)
         except exception.FixedIpNotFoundForInstance:
             fixed_ips = []
@@ -366,11 +359,11 @@ class FloatingIP(object):
             # disassociate floating ips related to fixed_ip
             for floating_ip in floating_ips:
                 address = floating_ip['address']
-                self.disassociate_floating_ip(read_deleted_context, address,
+                self.disassociate_floating_ip(context, address,
                                               affect_auto_assigned=True)
                 # deallocate if auto_assigned
                 if floating_ip['auto_assigned']:
-                    self.deallocate_floating_ip(read_deleted_context, address,
+                    self.deallocate_floating_ip(context, address,
                                                 affect_auto_assigned=True)
 
         # call the next inherited class's deallocate_for_instance()
diff --git a/nova/tests/network/test_manager.py b/nova/tests/network/test_manager.py
index 4a7e2ef..7804822 100644
--- a/nova/tests/network/test_manager.py
+++ b/nova/tests/network/test_manager.py
@@ -1459,10 +1459,45 @@ class FloatingIPTestCase(test.TestCase):
                 instance_id=instance_ref['id'])
 
     def test_deallocation_deleted_instance(self):
-        instance_ref = db.api.instance_create(self.context,
-                {"project_id": self.project_id, "deleted": True})
+        self.stubs.Set(self.network, '_teardown_network_on_host',
+                       lambda *args, **kwargs: None)
+        instance = db.api.instance_create(self.context, {
+                'project_id': self.project_id, 'deleted': True})
+        network = db.api.network_create_safe(self.context.elevated(), {
+                'project_id': self.project_id})
+        addr = db.fixed_ip_create(self.context, {'allocated': True,
+                'instance_uuid': instance['uuid'], 'address': '10.1.1.1',
+                'network_id': network['id']})
+        fixed = db.fixed_ip_get_by_address(
+                self.context.elevated(read_deleted='yes'), addr)
+        db.api.floating_ip_create(self.context, {
+                'address': '10.10.10.10', 'instance_uuid': instance['uuid'],
+                'fixed_ip_id': fixed['id'],
+                'project_id': self.project_id})
         self.network.deallocate_for_instance(self.context,
-                instance_id=instance_ref['id'])
+                instance_id=instance['id'])
+
+    def test_deallocation_duplicate_floating_ip(self):
+        self.stubs.Set(self.network, '_teardown_network_on_host',
+                       lambda *args, **kwargs: None)
+        instance = db.api.instance_create(self.context, {
+                'project_id': self.project_id})
+        network = db.api.network_create_safe(self.context.elevated(), {
+                'project_id': self.project_id})
+        addr = db.fixed_ip_create(self.context, {'allocated': True,
+                'instance_uuid': instance['uuid'], 'address': '10.1.1.1',
+                'network_id': network['id']})
+        fixed = db.fixed_ip_get_by_address(
+                self.context.elevated(read_deleted='yes'), addr)
+        db.api.floating_ip_create(self.context, {
+                'address': '10.10.10.10',
+                'deleted': True})
+        db.api.floating_ip_create(self.context, {
+                'address': '10.10.10.10', 'instance_uuid': instance['uuid'],
+                'fixed_ip_id': fixed['id'],
+                'project_id': self.project_id})
+        self.network.deallocate_for_instance(self.context,
+                instance_id=instance['id'])
 
     def test_floating_dns_create_conflict(self):
         zone = "example.org"
-- 
1.7.11.4

